#include "StdAfx.h"
#include "DuplexConnection.h"
#include "SocketsException.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::DuplexConnection::DuplexConnection(ClientSocket sock) : m_IsSending{ false }, m_IsReceiving{ false }, m_ClientSocket{ std::move(sock) }
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::DuplexConnection::DuplexConnection(std::string_view addr, uint16_t port) : DuplexConnection{ ClientSocket(addr, port) }
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::DuplexConnection::~DuplexConnection()
{
	{
		std::unique_lock lock(m_MessagesMutex);
		Stop();
	}
	m_NewMessage.notify_all();
	if (m_SendingThread.joinable())
		m_SendingThread.join();
	if (m_ReceivingThread.joinable())
		m_ReceivingThread.join();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void MWR::DuplexConnection::StartSending()
{
	m_IsSending = true;
	m_SendingThread = std::thread([this]
	{
		try
		{
			while (true)
			{
				ByteVector message;
				{
					std::unique_lock lock(m_MessagesMutex);
					if (!m_IsSending)
						break;
					message = GetMessage(lock);
					if (message.empty())
						break; // connection closed
				}
				m_ClientSocket.Send(message);
			}
		}
		catch (MWR::SocketsException&)
		{
			Stop();
		}
	});
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector MWR::DuplexConnection::Receive()
{
	return m_ClientSocket.Receive();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void MWR::DuplexConnection::StartReceiving(std::function<void(ByteView)> callback)
{
	m_IsReceiving = true;
	m_ReceivingThread = std::thread([this, callback]()
	{
		try
		{
			while (true)
			{
				if (m_IsReceiving && !m_ClientSocket.HasReceivedData())
				{
					std::this_thread::sleep_for(10ms);
					continue;
				}
				if (!m_IsReceiving)
					break;

				auto message = Receive();
				if (!m_IsReceiving || message.empty())
					break;
				callback(message);
			}
		}
		catch (MWR::SocketsException&)
		{
			Stop();
		}
	});
}

void MWR::DuplexConnection::Stop()
{
	m_IsSending = false;
	m_IsReceiving = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool MWR::DuplexConnection::IsSending() const
{
	return m_IsSending;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void MWR::DuplexConnection::Send(ByteVector message)
{
	std::scoped_lock lock(m_MessagesMutex);
	m_Messages.emplace(std::move(message));
	m_NewMessage.notify_one();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector MWR::DuplexConnection::GetMessage(std::unique_lock<std::mutex>& lock)
{
	auto popMessage = [this]
	{
		auto ret = m_Messages.front();
		m_Messages.pop();
		return ret;
	};

	if (!m_Messages.empty())
	{
		return popMessage();
	}
	else
	{
		while (true)
		{
			m_NewMessage.wait(lock);
			if (!m_IsSending)
				return {}; // stop requested
			else if (!m_Messages.empty())
				return popMessage();
			else
				continue; // condition_variable spuriously unlocked, go back to waiting
		}
	}
}
